{
  "name": "Methodinvocationlogger",
  "tagline": "Real cross-cutting logger. No more interferance with business code",
  "body": "# MethodInvocationLogger\r\n\r\nThis library allows to log invocations of specified methods declared in classes which instances are resolved using dependency injection. Currently `Castle.Windsor` is the only supported container, but I plan to add others. Logger could be usefull in application performance monitor (analyzing duration of method execution), creating events for BI and many others because logs output could be anything. \r\nThe most important advantage is separation of concerns - logging is completly separated from business logic.\r\n\r\n```csharp\r\n// log execution of PutSomeData method in SomeApiClient\r\nlogger.LogInvocationOf<SomeApiClient>(t => t.PutSomeData(Input.Param<FormData>(\"formData\"), Input.Param<Data>()))\r\n\t\t\t\t.WithInvocationTime() // log time of execution\r\n\t\t\t\t.WithExecutionDuration() // log duration of execution \r\n\t\t\t\t.WithAllArguments() // log every argument of a method\r\n\t\t\t\t.WithMethodName() // log name of a method\r\n\t\t\t\t.WithAdditionalData<int, IUserContext>((context, data) => context.UserId, \"UserId\") // log userId from current user context\r\n\t\t\t\t.OnlyIfSucceeded() // log only if method succeeded\r\n\t\t\t\t.OnCondition((container, data) => data.Arguments.Get<FormData>(\"formData\").FormType != FormType.FormABC); // log only for specifed input\r\n```\r\n## Usage\r\n\r\nInstall logger using following NuGet command:\r\n```\r\n  PM> Install-Package MethodInvocationLogger.Castle\r\n  ```\r\nThis will install two packages: `MethodInvocationLogger` and `MethodInvocationLogger.Castle`\r\n\r\nLet's say you've got a Component class with Test() and Test(int x) methods.\r\n```csharp\r\ninterface IComponent\r\n{\r\n    void Test();\r\n    void Test(int x);\r\n}\r\n\r\nclass TestComponent : IComponent\r\n{\r\n    public void Test()\r\n    {\r\n        // some stuff\r\n    }\r\n    public void Test(int x)\r\n    {\r\n        // some stuff\r\n    }\r\n}\r\n```\r\nand you want log every invocation of `Test()` and `Test(int x)` methods.\r\n\r\nFirst you need to pick a class which will carry information about method's invocations. You could create your own class or use universal `DictionaryLogData` supplied by the library. Actually, it is a simple `Dictionary<string, object>`\r\n\r\nThen you have to pick a logger output. There are two sample writers in this repository.\r\n\r\n- `ElasticSearchLogWriter`, which writes logs into `ElasticSearch` server. With `Kibana` you can create very useful real-time dashboards ( [http://i.imgur.com/ONPB1fe.png] - this is a performance monitor of a microservice in a big commercial system which I am working on)\r\n\r\n- `SqlDataWriter` - usefull for giving business events to BI warehouse.\r\n\r\nAlthough for this example it will be simple custom console writer\r\n```csharp\r\nclass ConsoleOutput : ILogOutput<DictionaryLogData>\r\n{\r\n    public void WriteLog(DictionaryLogData logData)\r\n    {\r\n        Console.WriteLine(DateTime.Now + \" - \" + string.Join(\" \", logData.Select(i => i.Key + \":\" + i.Value)));\r\n    }\r\n}\r\n```\r\nNow you've got everything you need to create and initialize a logger\r\n```csharp\r\nvar logger = LoggerFactory.Create<DictionaryLogData>()\r\n\t\t.WriteTo(new ConsoleOutput())\r\n\t\t.BindToWindsor(container.Kernel);\r\n```\r\nConfigure logger to log every execution of `Test()` and `Test(int x)` methods in `Component`\r\n```csharp\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test());\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test(Input.Param<int>()));\r\n```\r\nIt is important to configure logger (set up methods you want to log) before you register components in a container. To be sure that everything is ok you should execute `Validate()` after you configured logger and registered components in a container.\r\n```csharp\r\ncontainer.Register(Component.For<IComponent>().ImplementedBy<TestComponent>());\r\nlogger.Validate(container.Kernel);\r\n```\r\nThis method will throw an exception if something is wrong with logger configuration.\r\n\r\nNow if you resolve `TestComponent` from a container and execute `Test()`\r\n```csharp\r\ncontainer.Resolve<IComponent>().Test();\r\n```\r\na method `WriteLog()` in `ConsoleOutput` will be invoked and print a message:\r\n```\r\n2016-05-28 09:59:04 -\r\n```\r\nSo, method's invocation was logged but `ConsoleOutput` was given empty `logData`. To fulfill this object you need to set `PrepareLogData` action in a logger configuration for specified method. For example:\r\n```csharp\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test())\r\n        .PrepareLogData((container1, invocationData, logData) =>\r\n        {\r\n            logData[\"duration\"] = invocationData.Raw.Duration;\r\n        });\r\n```\r\n`PrepareLogData` action will be executed after specified method finished. It has 3 arguments.\r\n- `container` - abstraction of a dependency injection container, which allows to resolving components.\r\n- `invocationData` - contains informations about invoked method: passed arguments, duration of execution, exception if method failed, returned value, instance of an object on which method was executed and few others\r\n- `logData` - an object which will be passed to `LogOutput`.\r\n\r\nYou could set as many `PrepareLogData` actions as you want. They will execute synchronously. If you discover that some of them are duplicated for many methods you want to log, it is useful to create extension methods from them. For example if you often want to log currently logged user\r\n```csharp\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test())\t\t\t\t\r\n\t\t\t\t.PrepareLogData((container1, invocationData, logData) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tIUserContext userContext = container1.Resolve<IUserContext>();\r\n\t\t\t\t\tlogData[\"LoggedUser\"] = userContext.UserName;\r\n\t\t\t\t\tcontainer1.Release(userContext);\r\n\t\t\t\t});\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test(Input.Param<int>())\r\n\t\t\t\t.PrepareLogData((container1, invocationData, logData) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tIUserContext userContext = container1.Resolve<IUserContext>();\r\n\t\t\t\t\tlogData[\"LoggedUser\"] = userContext.UserName;\r\n\t\t\t\t\tcontainer1.Release(userContext);\r\n\t\t\t\t});\r\n```\r\nYou could create an extension method\r\n```csharp\r\npublic static class ExtensionMethods\r\n{\r\n\t\tpublic static MethodInvocationLoggingConfiguration<DictionaryLogData> WithCurrentUserName(\r\n\t\t\tthis MethodInvocationLoggingConfiguration<DictionaryLogData> config)\r\n\t\t{\r\n\t\t    return config.PrepareLogData(((container, invocationData, logData) =>\r\n\t\t\t  {\r\n  \t\t\t\tIUserContext userContext = container.Resolve<IUserContext>();\r\n\t\t\t\t  logData[\"LoggedUser\"] = userContext.UserName;\r\n\t\t\t\t  container.Release(userContext);\r\n\t\t\t  }));\r\n\t\t}\r\n}\r\n```\r\nand use it like this\r\n```csharp\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test())\r\n\t\t\t\t.WithCurrentUserName()\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test(Input.Param<int>())\r\n\t\t\t\t.WithCurrentUserName()\r\n```\r\nIf you are using `DictionaryLogData` you could use many predefined extension methods from `MethodInvocationLogger.Extensions` namespace.\r\n\r\n##Filters\r\nIf there is a need to log method invocation only in certain circumstances, you could use `OnCondition` function. Let say that you want to log invocation of method `Test(int x)` only if `x` is more than `10`\r\n```csharp\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test(Input.Param<int>())\r\n\t.OnCondition((container1, data) => data.Arguments.Get<int>(\"x\") > 10);\r\n```\r\nHere `data` is the same object as in the `PrepareLogData` action and same as with `PrepareLogData` it's useful to aggregate `OnCondition` functions using extension methods, which makes configuring logger nice and fluent.\r\n\r\n##Naming arguments\r\n\r\nYou could retrieve arguments by their names (like in the example above) or by index. Retrieving by names could be risky because if you change argument's name in a method signature and forget to update it in a logger configuration, there will be no compilation error but method will throw an exception. To prevent this you can name arguments in a logging scope using `Input.Param<int>(string name)`\r\n```csharp\r\nlogger.LogInvocationOf<TestComponent>(c => c.Test(Input.Param<int>(\"ourParamName\"))\r\n\t.OnCondition((container1, data) => data.Arguments.Get<int>(\"ourParamName\") > 10);\r\n```\r\nNow it doesn't matter what names have parameters in method signature.\r\n\r\n##Demo\r\nThere is a demo web aplication in a repository (`MethodInvocationLogger.Demo`), which is an example of using loggers as a performance tool and as business event generator. The logging code is in `global.asax.cs` file.",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}